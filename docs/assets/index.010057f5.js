var e=Object.defineProperty,t=Object.defineProperties,o=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,i=(t,o,n)=>o in t?e(t,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[o]=n,s=(e,t)=>{for(var o in t||(t={}))a.call(t,o)&&i(e,o,t[o]);if(n)for(var o of n(t))r.call(t,o)&&i(e,o,t[o]);return e};import{c as l,u as c,r as m,V as u,a as h,R as d,b as p,S as f,P as v,d as g,e as y,s as x,D as w,f as E,g as b,h as M,G as A,i as k,T as C,j as z,C as S,k as P,l as L}from"./vendor.f6e0e506.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerpolicy&&(t.referrerPolicy=e.referrerpolicy),"use-credentials"===e.crossorigin?t.credentials="include":"anonymous"===e.crossorigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const _=l((e=>({position:[0,0,0],velocity:[0,0,0],rotation:[0,0,0],setVelocity:t=>e({velocity:t}),increaseVelocityUp:()=>e((e=>({velocity:[e.velocity[0],e.velocity[1]+1,e.velocity[2]]}))),stopVelocity:()=>e({velocity:[0,0,0]})}))),O=e=>e*(Math.PI/180),R=e=>e/(1+Math.abs(e)),j=e=>{const t=m.exports.useRef();return h((e=>{const[o,n,a]=_.getState().velocity;t.current.rotation.set(0,35*O(Math.sin(n+o+4*e.clock.getElapsedTime())),0)})),d.createElement("group",{ref:t,position:[-1,0,0]},d.createElement(p,{args:[.6,.6,.2],position:[-.2,0,0],radius:.05,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[.75,.4,.1],position:[-.6,.15,0],radius:.05,smoothness:2,rotation:[0,0,-10]},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[.75,.4,.1],position:[-.6,-.15,0],radius:.05,smoothness:2,rotation:[0,0,10]},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})))},D=e=>{const n=m.exports.useRef(),a=new u;return h((t=>{const[o,r,i]=_.getState().velocity,s=a.lerp(a.set(R(-.1*r),.1*R(-1*r)+.5,0),.25);n.current.setRotationFromAxisAngle(s.normalize(),e.mirror?-10:.5)})),d.createElement("group",(r=s({},e),t(r,o({ref:n}))),d.createElement(f,{position:[0,0,0],args:[.3]},d.createElement("meshPhongMaterial",{attach:"material",color:"#f3f3f3"})),d.createElement(f,{position:[0,0,.25],args:[.1]},d.createElement("meshPhongMaterial",{translate:[0,10,.25],attach:"material",color:"black"})));var r},I=e=>{const[t,o]=c((()=>s({mass:1,position:[0,0,0],linearDamping:.5},e))),n=m.exports.useRef(),a=m.exports.useRef(),r=new u;return console.log("Player"),m.exports.useEffect((()=>{const e=o.velocity.subscribe((e=>{_.setState({velocity:e})})),t=o.position.subscribe((e=>{_.setState({position:e})})),n=o.rotation.subscribe((e=>{_.setState({rotation:e})}));return()=>{e(),t(),n()}}),[]),h((t=>{const[i,s,l]=_.getState().velocity;e.up&&o.velocity.set(i,s+.2,l),e.down&&o.velocity.set(i,s-.2,l),e.right&&o.velocity.set(i+1,s,l),e.left&&o.velocity.set(i-1,s,l);const c=-10*Math.sin(s+i+4*t.clock.getElapsedTime()),m=r.lerp(r.set(0,O(180*(.5*R(.25*i)-.5)+c),O(60*R(s/5))),.1);o.rotation.set(0,m.y,m.z),n.current.setRotationFromAxisAngle(r.lerp(r.set(R(.5*s),-.8,0),.25),.5),a.current.setRotationFromAxisAngle(r.lerp(r.set(-1*R(.5*s),.8,0),.25),.5)})),d.createElement("group",{ref:t},d.createElement(p,{args:[1.5,1.2,.8],position:[.25,.1,0],radius:.2,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[1,.75,.6],position:[-.5,.05,0],radius:.2,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[.7,.5,.8],position:[.8,-.25,0],rotation:[0,0,0],radius:.1,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[.5,.5,.05],position:[.25,.7,0],radius:.05,smoothness:2,rotation:[0,0,10]},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{ref:n,args:[.5,.1,.6],position:[-0,-.25,.4],radius:.05,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{ref:a,args:[.5,.1,.6],position:[-0,-.25,-.4],radius:.05,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:(null==e?void 0:e.color)||"purple"})),d.createElement(p,{args:[.1,.1,.5],position:[1.15,-.4,0],radius:.05,smoothness:2},d.createElement("meshPhongMaterial",{attach:"material",color:"black"})),d.createElement(D,{position:[.6,.1,.35]}),d.createElement(D,{position:[.6,.1,-.35],mirror:!0}),d.createElement(j,{color:e.color}))},B=e=>{const[t]=g((()=>s({rotation:[-Math.PI/2,0,0],position:[0,-10,0]},e)));return d.createElement("mesh",{ref:t,receiveShadow:!0},d.createElement("planeBufferGeometry",{attach:"geometry",args:[1e3,1e3]}),d.createElement("shadowMaterial",{attach:"material",color:"#171717"}),d.createElement("meshStandardMaterial",{color:"#615637"}))},F=e=>{const[t,o]=m.exports.useState(!1),[n,a]=m.exports.useState(!1),[r,i]=m.exports.useState(!1),[s,l]=m.exports.useState(!1);m.exports.useRef([0,-10,0]);const[c,u]=m.exports.useState([0,-10,0]);return console.log("Scene"),m.exports.useEffect((()=>{const e=e=>{38===e.keyCode||87===e.keyCode||32===e.keyCode?o(!0):37===e.keyCode||65===e.keyCode?i(!0):39===e.keyCode||68===e.keyCode?l(!0):40===e.keyCode||83===e.keyCode?a(!0):e.keyCode},t=e=>{38===e.keyCode||87===e.keyCode||32===e.keyCode?(console.log("up keyup"),o(!1)):37===e.keyCode||65===e.keyCode?i(!1):39===e.keyCode||68===e.keyCode?l(!1):40===e.keyCode||83===e.keyCode?a(!1):e.keyCode},n=()=>{o(!0)},r=()=>{o(!1)};return window.addEventListener("keydown",e),window.addEventListener("keyup",t),window.addEventListener("mousedown",n),window.addEventListener("mouseup",r),window.addEventListener("touchstart",n),window.addEventListener("touchend",r),()=>{window.removeEventListener("keydown",e),window.removeEventListener("keyup",t),window.removeEventListener("mousedown",n),window.removeEventListener("mouseup",r),window.removeEventListener("touchstart",n),window.removeEventListener("touchend",r)}}),[]),h((e=>{const[t,o,n]=_.getState().position;u([t<-10?10:t>10?-10:-1*t,o<-10?10:o>10?-10:-1*o,n<-10?10:n>10?-10:-1*n])})),d.createElement(d.Fragment,null,d.createElement("pointLight",{position:[10,10,-10],decay:10,intensity:2}),d.createElement(v,{gravity:c,tolerance:.1},d.createElement(I,{color:"red",up:t,down:n,left:r,right:s}),d.createElement(B,null)))};y({GrassMaterial:x({bladeHeight:1,map:null,alphaMap:null,time:0},"   precision mediump float;\n      attribute vec3 offset;\n      attribute vec4 orientation;\n      attribute float halfRootAngleSin;\n      attribute float halfRootAngleCos;\n      attribute float stretch;\n      uniform float time;\n      uniform float bladeHeight;\n      varying vec2 vUv;\n      varying float frc;\n      \n      //WEBGL-NOISE FROM https://github.com/stegu/webgl-noise\n      //Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise      \n      vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);} float snoise(vec2 v){const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g);}\n      //END NOISE\n      \n      //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n      vec3 rotateVectorByQuaternion( vec3 v, vec4 q){\n        return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n      }\n      \n      //https://en.wikipedia.org/wiki/Slerp\n      vec4 slerp(vec4 v0, vec4 v1, float t) {\n        // Only unit quaternions are valid rotations.\n        // Normalize to avoid undefined behavior.\n        normalize(v0);\n        normalize(v1);\n      \n        // Compute the cosine of the angle between the two vectors.\n        float dot_ = dot(v0, v1);\n      \n        // If the dot product is negative, slerp won't take\n        // the shorter path. Note that v1 and -v1 are equivalent when\n        // the negation is applied to all four components. Fix by \n        // reversing one quaternion.\n        if (dot_ < 0.0) {\n          v1 = -v1;\n          dot_ = -dot_;\n        }  \n      \n        const float DOT_THRESHOLD = 0.9995;\n        if (dot_ > DOT_THRESHOLD) {\n          // If the inputs are too close for comfort, linearly interpolate\n          // and normalize the result.\n          vec4 result = t*(v1 - v0) + v0;\n          normalize(result);\n          return result;\n        }\n      \n        // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n        float theta_0 = acos(dot_);       // theta_0 = angle between input vectors\n        float theta = theta_0*t;          // theta = angle between v0 and result\n        float sin_theta = sin(theta);     // compute this value only once\n        float sin_theta_0 = sin(theta_0); // compute this value only once\n        float s0 = cos(theta) - dot_ * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n        float s1 = sin_theta / sin_theta_0;\n        return (s0 * v0) + (s1 * v1);\n      }\n      \n      void main() {\n        //Relative position of vertex along the mesh Y direction\n        frc = position.y/float(bladeHeight);\n        //Get wind data from simplex noise \n        float noise = 1.0-(snoise(vec2((time-offset.x/50.0), (time-offset.z/50.0)))); \n        //Define the direction of an unbent blade of grass rotated around the Y axis\n        vec4 direction = vec4(0.0, halfRootAngleSin, 0.0, halfRootAngleCos);\n        //Interpolate between the unbent direction and the direction of growth calculated on the CPU. \n        //Using the relative location of the vertex along the Y axis as the weight, we get a smooth bend\n        direction = slerp(direction, orientation, frc);\n        vec3 vPosition = vec3(position.x, position.y + position.y * stretch, position.z);\n        vPosition = rotateVectorByQuaternion(vPosition, direction);\n      \n       //Apply wind\n       float halfAngle = noise * 0.15;\n        vPosition = rotateVectorByQuaternion(vPosition, normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle))));\n        //UV for texture\n        vUv = uv;\n        //Calculate final position of the vertex from the world offset and the above shenanigans \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(offset + vPosition, 1.0 );\n      }","\n      precision mediump float;\n      uniform sampler2D map;\n      uniform sampler2D alphaMap;\n      varying vec2 vUv;\n      varying float frc;\n      \n      void main() {\n        //Get transparency information from alpha map\n        float alpha = texture2D(alphaMap, vUv).r;\n        //If transparent, don't draw\n        if(alpha < 0.15) discard;\n        //Get colour data from texture\n        vec4 col = vec4(texture2D(map, vUv));\n        //Add more green towards root\n        col = mix(vec4(0.0, 0.6, 0.0, 1.0), col, frc);\n        //Add a shadow towards root\n        col = mix(vec4(0.0, 0.1, 0.0, 1.0), col, frc);\n        gl_FragColor = col;\n      }",(e=>{e.side=w,console.log("shader --\x3e",e)}))});const G=new E(Math.random);function H(e,t){const o=e.x*t.w+e.y*t.z-e.z*t.y+e.w*t.x,n=-e.x*t.z+e.y*t.w+e.z*t.x+e.w*t.y,a=e.x*t.y-e.y*t.x+e.z*t.w+e.w*t.z,r=-e.x*t.x-e.y*t.y-e.z*t.z+e.w*t.w;return new k(o,n,a,r)}function N(e,t){return.5*G.noise2D(e/20,t/20)}function T({options:e={bW:.12,bH:1,joints:5},width:t=200,instances:o=5e4}){const{bW:n,bH:a,joints:r}=e,i=m.exports.useRef(),[s,l]=b(C,["/swimmy-fish/assets/blade_diffuse.06f3b631.jpg","/swimmy-fish/assets/blade_alpha.586406fd.jpg"]),c=m.exports.useMemo((()=>function(e,t){const o=[],n=[],a=[],r=[],i=[];let s=new k;const l=new k,c=-.25;for(let m=0;m<e;m++){const h=Math.random()*t-t/2,d=Math.random()*t-t/2,p=N(h,d);o.push(h,p,d);let f=Math.PI-Math.random()*(2*Math.PI);r.push(Math.sin(.5*f)),i.push(Math.cos(.5*f));let v=new u(0,1,0),g=v.x*Math.sin(f/2),y=v.y*Math.sin(f/2),x=v.z*Math.sin(f/2),w=Math.cos(f/2);s.set(g,y,x,w).normalize(),f=.5*Math.random()+c,v=new u(1,0,0),g=v.x*Math.sin(f/2),y=v.y*Math.sin(f/2),x=v.z*Math.sin(f/2),w=Math.cos(f/2),l.set(g,y,x,w).normalize(),s=H(s,l),f=.5*Math.random()+c,v=new u(0,0,1),g=v.x*Math.sin(f/2),y=v.y*Math.sin(f/2),x=v.z*Math.sin(f/2),w=Math.cos(f/2),l.set(g,y,x,w).normalize(),s=H(s,l),n.push(s.x,s.y,s.z,s.w),m<e/3?a.push(1.8*Math.random()):a.push(Math.random())}return{offsets:o,orientations:n,stretches:a,halfRootAngleCos:i,halfRootAngleSin:r}}(o,t)),[o,t]),p=m.exports.useMemo((()=>new M(n,a,1,r).translate(0,a/2,0)),[a,n,r]),f=m.exports.useMemo((()=>{const e=(new A).fromBufferGeometry(new M(t,t,32,32));e.verticesNeedUpdate=!0,e.lookAt(new u(0,1,0));for(let t=0;t<e.vertices.length;t++){const o=e.vertices[t];o.y=N(o.x,o.z)}return e.computeVertexNormals(),e.toBufferGeometry()}),[t]);return h((e=>i.current.uniforms.time.value=e.clock.elapsedTime/4)),d.createElement(d.Fragment,null,d.createElement("mesh",{position:[0,-10,-30]},d.createElement("instancedBufferGeometry",{index:p.index,"attributes-position":p.attributes.position,"attributes-uv":p.attributes.uv},d.createElement("instancedBufferAttribute",{attachObject:["attributes","offset"],args:[new Float32Array(c.offsets),3]}),d.createElement("instancedBufferAttribute",{attachObject:["attributes","orientation"],args:[new Float32Array(c.orientations),4]}),d.createElement("instancedBufferAttribute",{attachObject:["attributes","stretch"],args:[new Float32Array(c.stretches),1]}),d.createElement("instancedBufferAttribute",{attachObject:["attributes","halfRootAngleSin"],args:[new Float32Array(c.halfRootAngleSin),1]}),d.createElement("instancedBufferAttribute",{attachObject:["attributes","halfRootAngleCos"],args:[new Float32Array(c.halfRootAngleCos),1]})),d.createElement("grassMaterial",{ref:i,map:s,alphaMap:l})),d.createElement("mesh",{position:[5,-10,-30],geometry:f},d.createElement("meshStandardMaterial",{color:"#4f4528"})))}const U=z.div`
  width: 100vw;
  height: 100vh;
`,V=()=>{const e=new u;return console.log("Camera movement"),h((t=>{const[o,n,a]=_.getState().position,r=e.lerp(e.set(o,n,a),.05);t.camera.lookAt(r),t.camera.position.x=r.x,t.camera.position.z=20,t.camera.updateProjectionMatrix()})),null},q=()=>(console.log("Scene mounted"),d.createElement(U,null,d.createElement(S,{shadows:!0,colorManagement:!0,camera:{position:[0,0,20],fov:35,far:300,near:.1}},d.createElement("ambientLight",null),d.createElement("pointLight",{position:[10,10,10]}),d.createElement(F,null),d.createElement(P,{azimuth:.1,turbidity:5,rayleigh:0,inclination:.6,sunPosition:[.1,0,-5],distance:1e4}),d.createElement(m.exports.Suspense,{fallback:null},d.createElement(T,null)),d.createElement(V,null))));L.render(d.createElement(d.StrictMode,null,d.createElement(q,null)),document.getElementById("root"));
