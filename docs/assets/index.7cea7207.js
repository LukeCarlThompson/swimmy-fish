var e=Object.defineProperty,t=Object.defineProperties,o=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,i=(t,o,n)=>o in t?e(t,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[o]=n,s=(e,t)=>{for(var o in t||(t={}))r.call(t,o)&&i(e,o,t[o]);if(n)for(var o of n(t))a.call(t,o)&&i(e,o,t[o]);return e};import{c as l,u as c,r as m,V as d,a as p,R as u,b as v,S as h,d as f,P as g,e as y,f as E,s as x,D as w,g as b,h as S,C as k,i as C,j as z}from"./vendor.128165c8.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerpolicy&&(t.referrerPolicy=e.referrerpolicy),"use-credentials"===e.crossorigin?t.credentials="include":"anonymous"===e.crossorigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const L=l((e=>({position:[0,0,0],velocity:[0,0,0],rotation:[0,0,0],mousePosition:[0,0,0]}))),_=e=>e*(Math.PI/180),A=e=>e/(1+Math.abs(e)),P=e=>u.createElement("meshPhongMaterial",{attach:"material",flatShading:!1,specular:"#eff41c",color:e.color||"purple"}),M=e=>{const t=m.exports.useRef(),o=m.exports.useRef(),n=m.exports.useRef();return p((e=>{const[r,a,i]=L.getState().velocity,s=_(Math.sin(a+r+4*e.clock.getElapsedTime()));t.current.rotation.set(0,10*s,0),o.current.rotation.set(0,20*s,0),n.current.rotation.set(0,20*s,0)})),u.createElement("group",{ref:t},u.createElement(v,{args:[1,.75,.6],position:[-.5,.05,0],radius:.2,smoothness:4},u.createElement(P,{color:e.color})),u.createElement("group",{ref:o,position:[-1,0,0]},u.createElement(v,{args:[.6,.6,.3],position:[-.1,0,0],radius:.05,smoothness:4},u.createElement(P,{color:e.color})),u.createElement("group",{ref:n,position:[-.4,0,0]},u.createElement(v,{args:[.75,.4,.1],position:[-.1,.15,0],radius:.05,smoothness:4,rotation:[0,0,-10]},u.createElement(P,{color:e.color})),u.createElement(v,{args:[.75,.4,.1],position:[-.1,-.15,0],radius:.05,smoothness:4,rotation:[0,0,10]},u.createElement(P,{color:e.color})))))},R=e=>{const n=m.exports.useRef(),r=new d;return p((t=>{const[o,a,i]=L.getState().velocity,s=r.lerp(r.set(A(-.1*a),.1*A(-1*a)+.5,0),.25);n.current.setRotationFromAxisAngle(s.normalize(),e.mirror?-10:.5)})),u.createElement("group",(a=s({},e),t(a,o({ref:n}))),u.createElement(h,{position:[0,0,0],args:[.3]},u.createElement(P,{translate:[0,10,.25],attach:"material",color:"#f3f3f3"})),u.createElement(h,{position:[0,0,.25],args:[.1]},u.createElement(P,{translate:[0,10,.25],attach:"material",color:"black"})));var a},O=e=>{const[t,o]=c((()=>s({mass:1,position:[0,0,0],linearDamping:.5,linearFactor:[1,1,0],angularFactor:[1,1,0]},e))),n=m.exports.useRef(),r=m.exports.useRef(),a=new d;return console.log("Player"),m.exports.useEffect((()=>{const e=o.velocity.subscribe((e=>{L.setState({velocity:e})})),t=o.position.subscribe((e=>{L.setState({position:e})})),n=o.rotation.subscribe((e=>{L.setState({rotation:e})}));return()=>{e(),t(),n()}}),[]),p((t=>{const[i,s,l]=L.getState().velocity,[c,m]=L.getState().mousePosition;e.up&&o.velocity.set(i,s+.2,l),e.down&&o.velocity.set(i,s-.2,l),e.right&&o.velocity.set(i+1,s,l),e.left&&o.velocity.set(i-1,s,l),e.applyForce&&o.velocity.set(i+.1*c,s+.1*m,l);const d=-10*Math.sin(s+i+4*t.clock.getElapsedTime()),p=a.lerp(a.set(0,_(180*(.5*A(.25*i)-.5)+d),_(60*A(s/5))),.1);o.rotation.set(0,p.y,p.z),n.current.setRotationFromAxisAngle(a.lerp(a.set(A(1*s),-1,0),.25),.5),r.current.setRotationFromAxisAngle(a.lerp(a.set(-1*A(1*s),1,0),.25),.5)})),u.createElement("group",{ref:t},u.createElement(v,{args:[1.5,1.2,.8],position:[.25,.1,0],radius:.2,smoothness:4},u.createElement(P,{color:e.color})),u.createElement(v,{args:[.7,.5,.8],position:[.8,-.25,0],rotation:[0,0,0],radius:.1,smoothness:6},u.createElement(P,{color:e.color})),u.createElement(v,{args:[.5,.5,.05],position:[.25,.7,0],radius:.05,smoothness:4,rotation:[0,0,10]},u.createElement(P,{color:e.color})),u.createElement(v,{ref:n,args:[.5,.1,.6],position:[-0,-.25,.4],radius:.05,smoothness:4},u.createElement(P,{color:e.color})),u.createElement(v,{ref:r,args:[.5,.1,.6],position:[-0,-.25,-.4],radius:.05,smoothness:4},u.createElement(P,{color:e.color})),u.createElement(v,{args:[.1,.1,.5],position:[1.15,-.4,0],radius:.05,smoothness:4},u.createElement("meshPhysicalMaterial",{attach:"material",color:"black"})),u.createElement(R,{position:[.6,.1,.35]}),u.createElement(R,{position:[.6,.1,-.35],mirror:!0}),u.createElement(M,{color:e.color}))},D=e=>u.createElement("meshPhongMaterial",{attach:"material",flatShading:!1,specular:"#eff41c",color:e.color||"purple"}),I=e=>{const t=e.size||.5,[o,n]=f((()=>s({mass:.2*t,position:e.position,linearDamping:.9,linearFactor:[1,1,0],args:t},e)));return m.exports.useRef(e.position),console.log("Ball"),p((e=>{})),u.createElement("group",{ref:o},u.createElement(h,{position:[0,0,0],args:[t]},u.createElement(D,{translate:[0,0,0],attach:"material",color:"pink"})))},F=e=>{const[t]=y((()=>s({rotation:[-Math.PI/2,0,0],position:[0,-10,0]},e)));return u.createElement("mesh",{ref:t,receiveShadow:!0},u.createElement("planeBufferGeometry",{attach:"geometry",args:[1e3,1e3]}),u.createElement("shadowMaterial",{attach:"material",color:"#171717"}),u.createElement("meshStandardMaterial",{color:"#615637"}))},j=e=>{const[t,o]=m.exports.useState(!1),[n,r]=m.exports.useState(!1),[a,i]=m.exports.useState(!1),[s,l]=m.exports.useState(!1),[c,d]=m.exports.useState(!1),v=m.exports.useRef([0,0,0]);return m.exports.useState([0,-10,0]),console.log("Scene"),m.exports.useEffect((()=>{const e=e=>{38===e.keyCode||87===e.keyCode||32===e.keyCode?o(!0):37===e.keyCode||65===e.keyCode?i(!0):39===e.keyCode||68===e.keyCode?l(!0):40===e.keyCode||83===e.keyCode?r(!0):e.keyCode},t=e=>{38===e.keyCode||87===e.keyCode||32===e.keyCode?(console.log("up keyup"),o(!1)):37===e.keyCode||65===e.keyCode?i(!1):39===e.keyCode||68===e.keyCode?l(!1):40===e.keyCode||83===e.keyCode?r(!1):e.keyCode},n=()=>{d(!0)},a=()=>{d(!1)};return window.addEventListener("keydown",e),window.addEventListener("keyup",t),window.addEventListener("mousedown",n),window.addEventListener("mouseup",a),window.addEventListener("touchstart",n),window.addEventListener("touchend",a),()=>{window.removeEventListener("keydown",e),window.removeEventListener("keyup",t),window.removeEventListener("mousedown",n),window.removeEventListener("mouseup",a),window.removeEventListener("touchstart",n),window.removeEventListener("touchend",a)}}),[]),p((e=>{const{mouse:t,viewport:o}=e;L.getState().position;const n=t.x*o.width/2,r=t.y*o.height/2;v.current=[n,r,0],L.setState({mousePosition:[n,r,0]})})),u.createElement(u.Fragment,null,u.createElement("pointLight",{position:[10,10,-10],decay:10,intensity:2}),u.createElement(g,{gravity:[0,0,0],tolerance:.1},u.createElement(O,{color:"#e65b05",up:t,down:n,left:a,right:s,applyForce:c}),u.createElement(I,{position:[5,0,0],size:.75}),u.createElement(I,{position:[6,2,0],size:.25}),u.createElement(I,{position:[6,2,0],size:.25}),u.createElement(I,{position:[6,2,0],size:.25}),u.createElement(I,{position:[6,2,0],size:.2}),u.createElement(I,{position:[6,2,0],size:.15}),u.createElement(I,{position:[6,2,0],size:.35}),u.createElement(I,{position:[6,2,0],size:.25}),u.createElement(I,{position:[-2,-5,0]}),u.createElement(I,{position:[-3,-3,0],size:1.2}),u.createElement(I,{position:[-7,-5,0],size:.8}),u.createElement(F,null)))};E({GrassMaterial:x({bladeHeight:1,map:null,alphaMap:null,time:0},"   precision mediump float;\n      attribute vec3 offset;\n      attribute vec4 orientation;\n      attribute float halfRootAngleSin;\n      attribute float halfRootAngleCos;\n      attribute float stretch;\n      uniform float time;\n      uniform float bladeHeight;\n      varying vec2 vUv;\n      varying float frc;\n      \n      //WEBGL-NOISE FROM https://github.com/stegu/webgl-noise\n      //Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise      \n      vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);} float snoise(vec2 v){const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g);}\n      //END NOISE\n      \n      //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n      vec3 rotateVectorByQuaternion( vec3 v, vec4 q){\n        return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n      }\n      \n      //https://en.wikipedia.org/wiki/Slerp\n      vec4 slerp(vec4 v0, vec4 v1, float t) {\n        // Only unit quaternions are valid rotations.\n        // Normalize to avoid undefined behavior.\n        normalize(v0);\n        normalize(v1);\n      \n        // Compute the cosine of the angle between the two vectors.\n        float dot_ = dot(v0, v1);\n      \n        // If the dot product is negative, slerp won't take\n        // the shorter path. Note that v1 and -v1 are equivalent when\n        // the negation is applied to all four components. Fix by \n        // reversing one quaternion.\n        if (dot_ < 0.0) {\n          v1 = -v1;\n          dot_ = -dot_;\n        }  \n      \n        const float DOT_THRESHOLD = 0.9995;\n        if (dot_ > DOT_THRESHOLD) {\n          // If the inputs are too close for comfort, linearly interpolate\n          // and normalize the result.\n          vec4 result = t*(v1 - v0) + v0;\n          normalize(result);\n          return result;\n        }\n      \n        // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n        float theta_0 = acos(dot_);       // theta_0 = angle between input vectors\n        float theta = theta_0*t;          // theta = angle between v0 and result\n        float sin_theta = sin(theta);     // compute this value only once\n        float sin_theta_0 = sin(theta_0); // compute this value only once\n        float s0 = cos(theta) - dot_ * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n        float s1 = sin_theta / sin_theta_0;\n        return (s0 * v0) + (s1 * v1);\n      }\n      \n      void main() {\n        //Relative position of vertex along the mesh Y direction\n        frc = position.y/float(bladeHeight);\n        //Get wind data from simplex noise \n        float noise = 1.0-(snoise(vec2((time-offset.x/50.0), (time-offset.z/50.0)))); \n        //Define the direction of an unbent blade of grass rotated around the Y axis\n        vec4 direction = vec4(0.0, halfRootAngleSin, 0.0, halfRootAngleCos);\n        //Interpolate between the unbent direction and the direction of growth calculated on the CPU. \n        //Using the relative location of the vertex along the Y axis as the weight, we get a smooth bend\n        direction = slerp(direction, orientation, frc);\n        vec3 vPosition = vec3(position.x, position.y + position.y * stretch, position.z);\n        vPosition = rotateVectorByQuaternion(vPosition, direction);\n      \n       //Apply wind\n       float halfAngle = noise * 0.15;\n        vPosition = rotateVectorByQuaternion(vPosition, normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle))));\n        //UV for texture\n        vUv = uv;\n        //Calculate final position of the vertex from the world offset and the above shenanigans \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(offset + vPosition, 1.0 );\n      }","\n      precision mediump float;\n      uniform sampler2D map;\n      uniform sampler2D alphaMap;\n      varying vec2 vUv;\n      varying float frc;\n      \n      void main() {\n        //Get transparency information from alpha map\n        float alpha = texture2D(alphaMap, vUv).r;\n        //If transparent, don't draw\n        if(alpha < 0.15) discard;\n        //Get colour data from texture\n        vec4 col = vec4(texture2D(map, vUv));\n        //Add more green towards root\n        col = mix(vec4(0.0, 0.6, 0.0, 1.0), col, frc);\n        //Add a shadow towards root\n        col = mix(vec4(0.0, 0.1, 0.0, 1.0), col, frc);\n        gl_FragColor = col;\n      }",(e=>{e.side=w,console.log("shader --\x3e",e)}))}),new b(Math.random);const q=S.div`
  width: 100vw;
  height: 100vh;
  user-select: none;
`,H=()=>{const e=new d;return console.log("Camera movement"),p((t=>{const[o,n,r]=L.getState().position,a=e.lerp(e.set(o,n,r),.05);t.camera.lookAt(a),t.camera.position.x=a.x,t.camera.position.z=20,t.camera.updateProjectionMatrix()})),null},N=()=>(console.log("Scene mounted"),u.createElement(q,null,u.createElement(k,{shadows:!0,colorManagement:!0,camera:{position:[0,0,20],fov:45,far:300,near:.1}},u.createElement("ambientLight",{intensity:.75}),u.createElement("pointLight",{position:[0,100,-20]}),u.createElement(j,null),u.createElement(C,{azimuth:0,turbidity:5,rayleigh:0,inclination:.8,sunPosition:[.1,10,-5],distance:1e4}),u.createElement("fog",{attach:"fog",args:["#547f91",10,200]}),u.createElement(H,null))));z.render(u.createElement(u.StrictMode,null,u.createElement(N,null)),document.getElementById("root"));
